%{
open System
open AST
%}

%token <string> ID
%token KW_VAR KW_DEF KW_IF KW_ELSE KW_FOR KW_BREAK KW_CONTINUE KW_RETURN
%token OP_ADD OP_SUB OP_MUL OP_DIV OP_MOD
%token OP_ASSIGN
%token OP_AND OP_OR OP_NOT OP_EQ OP_NEQ
%token OP_GT OP_LT OP_GTE OP_LTE
%token OP_BITAND OP_BITOR OP_BITNOT OP_BITXOR
%token <int>	INT
%token <double> DOUBLE
%token <string> STRING
%token OPEN_PAREN
%token CLOSE_PAREN
%token OPEN_BLOCK
%token CLOSE_BLOCK
%token COMMA
%token COLON
%token SEMICOLON

%right OP_ASSIGN
%left OP_AND
%left OP_OR
%left OP_BITOR
%left OP_BITXOR
%left OP_BITAND
%left OP_EQ OP_NEQ
%nonassoc OP_GT OP_LT OP_GTE OP_LTE
%left OP_ADD OP_SUB
%left OP_MUL OP_DIV OP_MOD
%right OP_NOT OP_BITNOT

%start program

%type <Program> program

%%

program :
	| program toplevel	{ $2 :: $1 }

toplevel :
	| vardef	{ $1 }
	| funcdef	{ $1 }

stmt :
	| block		{ $1 }
	| vardef	{ $1 }
	| funcdef	{ $1 }
	| for		{ $1 }
	| while		{ $1 }
	| break		{ $1 }
	| continue	{ $1 }
	| return	{ $1 }

block :
	| OPEN_BLOCK stmt_list CLOSE_BLOCK			{ Block $2 }

vardef :
	| KW_VAR ID COLON ID OP_ASSIGN expr SEMICOLON	{ Var ($4, $2, $6) }

funcdef :
	| KW_DEF ID OPEN_PAREN args CLOSE_PAREN block	{ Func ($2, $4, $6) }

for :
	| KW_FOR OPEN_PAREN for_factor for_factor for_closing stmt		{ For ($3, $4, $5, $6) }

for_factor :
	| expr SEMICOLON				{ Some $1 }
	| SEMICOLON						{ None }

for_closing :
	| expr CLOSE_PAREN				{ Some $1 }
	| CLOSE_PAREN					{ None }

while :
	| KW_WHILE OPEN_PAREN expr CLOES_PAREN stmt	{ While ($3, $5) }

break :
	| KW_BREAK SEMICOLON			{ Break }

continue :
	| KW_CONTINUE SEMICOLON			{ Continue }

return :
	| KW_RETURN expr SEMICOLON		{ Return $2 }

expr :
	| unary_expr OP_ASSIGN expr		{ Expr.Binop ($1, $3, Assign) }
	| expr OP_OR expr				{ Expr.Binop ($1, $3, Or) }
	| expr OP_AND expr				{ Expr.Binop ($1, $3, And) }
	| expr OP_BITOR expr			{ Expr.Binop ($1, $3, Bitor) }
	| expr OP_BITXOR expr			{ Expr.Binop ($1, $3, Bitxor) }
	| expr OP_BITAND expr			{ Expr.Binop ($1, $3, Bitand) }
	| expr OP_EQ expr				{ Expr.Binop ($1, $3, Eq) }
	| expr OP_NEQ expr				{ Expr.Binop ($1, $3, Neq) }
	| expr OP_GT expr				{ Expr.Binop ($1, $3, Gt) }
	| expr OP_LT expr				{ Expr.Binop ($1, $3, Lt) }
	| expr OP_GTE expr				{ Expr.Binop ($1, $3, Gte) }
	| expr OP_LTE expr				{ Expr.Binop ($1, $3, Lte) }
	| expr OP_ADD expr				{ Expr.Binop ($1, $3, Add) }
	| expr OP_SUB expr				{ Expr.Binop ($1, $3, Sub) }
	| expr OP_MUL expr				{ Expr.Binop ($1, $3, Mul) }
	| expr OP_DIV expr				{ Expr.Binop ($1, $3, Div) }
	| expr OP_MOD expr				{ Expr.Binop ($1, $3, Mod) }
	| primary_expr					{ $1 }
	| unary_expr					{ $1 }

primary_expr :
	| ID							{ Primary.Var $1 }
	| INT							{ Primary.Int $1 }
	| DOUBLE						{ Primary.Double $1 }
	| STRING						{ Primary.String $1 }
	| OPEN_PAREN expr CLOSE_PAREN	{ $2 }

unary_expr :
	| OP_NOT expr					{ Expr.Unop ($2, Not) }
	| OP_BITNOT expr				{ Expr.Unop ($2, Bitnot) }

%%
